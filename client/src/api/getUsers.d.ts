/* tslint:disable */
/* DO NOT EDIT
   Generated by server/scripts/build-client-lib.js
*/

export interface Options {
  /**
   * Include parentheses around a sole arrow function parameter.
   */
  arrowParens?: "always" | "avoid";
  /**
   * Print spaces between brackets in object literals.
   */
  bracketSpacing?: boolean;
  /**
   * Which end of line characters to apply.
   */
  endOfLine?: "auto" | "cr" | "crlf" | "lf";
  /**
   * Specify the input filepath. This will be used to do parser inference.
   */
  filepath?: string;
  /**
   * How to handle whitespaces in HTML.
   */
  htmlWhitespaceSensitivity?: "css" | "ignore" | "strict";
  /**
   * Prettier can insert a special @format marker at the top of files specifying that
   * the file has been formatted with prettier. This works well when used in tandem with
   * the --require-pragma option. If there is already a docblock at the top of
   * the file then this option will add a newline to it with the @format marker.
   */
  insertPragma?: boolean;
  /**
   * Put the `>` of a multi-line JSX element at the end of the last line instead of being alone on the next line.
   */
  jsxBracketSameLine?: boolean;
  /**
   * Use single quotes in JSX.
   */
  jsxSingleQuote?: boolean;
  /**
   * Specify which parser to use.
   */
  parser?:
    | {
        [k: string]: any;
      }
    | (
        | "angular"
        | "babel"
        | "babel-flow"
        | "babylon"
        | "css"
        | "flow"
        | "graphql"
        | "html"
        | "json"
        | "json-stringify"
        | "json5"
        | "less"
        | "markdown"
        | "mdx"
        | "postcss"
        | "scss"
        | "typescript"
        | "vue"
        | "yaml");
  /**
   * The plugin API is in a beta state.
   */
  plugins?: (Plugin | string)[];
  /**
   * Specify the line length that the printer will wrap on.
   */
  printWidth?: number;
  /**
   * By default, Prettier will wrap markdown text as-is since some services use a linebreak-sensitive renderer.
   * In some cases you may want to rely on editor/viewer soft wrapping instead, so this option allows you to opt out.
   */
  proseWrap?: "always" | false | "never" | "preserve" | true;
  /**
   * Format only a segment of a file.
   */
  rangeEnd?: number;
  /**
   * Format only a segment of a file.
   */
  rangeStart?: number;
  /**
   * Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file.
   * This is very useful when gradually transitioning large, unformatted codebases to prettier.
   */
  requirePragma?: boolean;
  /**
   * Print semicolons at the ends of statements.
   */
  semi?: boolean;
  /**
   * Use single quotes instead of double quotes.
   */
  singleQuote?: boolean;
  /**
   * Specify the number of spaces per indentation-level.
   */
  tabWidth?: number;
  /**
   * Print trailing commas wherever possible.
   */
  trailingComma?: "all" | "es5" | "none";
  /**
   * Indent lines with tabs instead of spaces
   */
  useTabs?: boolean;
  [k: string]: any;
}
export interface Plugin {
  /**
   * Make all properties in T optional
   */
  defaultOptions?: {
    /**
     * Include parentheses around a sole arrow function parameter.
     */
    arrowParens?: "always" | "avoid";
    /**
     * Print spaces between brackets in object literals.
     */
    bracketSpacing?: boolean;
    /**
     * Which end of line characters to apply.
     */
    endOfLine?: "auto" | "cr" | "crlf" | "lf";
    /**
     * Specify the input filepath. This will be used to do parser inference.
     */
    filepath?: string;
    /**
     * How to handle whitespaces in HTML.
     */
    htmlWhitespaceSensitivity?: "css" | "ignore" | "strict";
    /**
     * Prettier can insert a special @format marker at the top of files specifying that
     * the file has been formatted with prettier. This works well when used in tandem with
     * the --require-pragma option. If there is already a docblock at the top of
     * the file then this option will add a newline to it with the @format marker.
     */
    insertPragma?: boolean;
    /**
     * Put the `>` of a multi-line JSX element at the end of the last line instead of being alone on the next line.
     */
    jsxBracketSameLine?: boolean;
    /**
     * Use single quotes in JSX.
     */
    jsxSingleQuote?: boolean;
    /**
     * Specify which parser to use.
     */
    parser?:
      | {
          [k: string]: any;
        }
      | (
          | "angular"
          | "babel"
          | "babel-flow"
          | "babylon"
          | "css"
          | "flow"
          | "graphql"
          | "html"
          | "json"
          | "json-stringify"
          | "json5"
          | "less"
          | "markdown"
          | "mdx"
          | "postcss"
          | "scss"
          | "typescript"
          | "vue"
          | "yaml");
    /**
     * The plugin API is in a beta state.
     */
    plugins?: (Plugin | string)[];
    /**
     * Specify the line length that the printer will wrap on.
     */
    printWidth?: number;
    /**
     * By default, Prettier will wrap markdown text as-is since some services use a linebreak-sensitive renderer.
     * In some cases you may want to rely on editor/viewer soft wrapping instead, so this option allows you to opt out.
     */
    proseWrap?: "always" | false | "never" | "preserve" | true;
    /**
     * Format only a segment of a file.
     */
    rangeEnd?: number;
    /**
     * Format only a segment of a file.
     */
    rangeStart?: number;
    /**
     * Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file.
     * This is very useful when gradually transitioning large, unformatted codebases to prettier.
     */
    requirePragma?: boolean;
    /**
     * Print semicolons at the ends of statements.
     */
    semi?: boolean;
    /**
     * Use single quotes instead of double quotes.
     */
    singleQuote?: boolean;
    /**
     * Specify the number of spaces per indentation-level.
     */
    tabWidth?: number;
    /**
     * Print trailing commas wherever possible.
     */
    trailingComma?: "all" | "es5" | "none";
    /**
     * Indent lines with tabs instead of spaces
     */
    useTabs?: boolean;
    [k: string]: any;
  };
  languages?: SupportLanguage[];
  options?: SupportOption[];
  parsers?: {
    [k: string]: Parser;
  };
  printers?: {
    [k: string]: Printer;
  };
  [k: string]: any;
}
export interface SupportLanguage {
  aceMode: string;
  aliases?: string[];
  codemirrorMimeType: string;
  codemirrorMode: string;
  extensions: string[];
  filenames?: string[];
  group?: string;
  linguistLanguageId: number;
  name: string;
  parsers:
    | string[]
    | (
        | "angular"
        | "babel"
        | "babel-flow"
        | "babylon"
        | "css"
        | "flow"
        | "graphql"
        | "html"
        | "json"
        | "json-stringify"
        | "json5"
        | "less"
        | "markdown"
        | "mdx"
        | "postcss"
        | "scss"
        | "typescript"
        | "vue"
        | "yaml")[];
  since?: string;
  tmScope: string;
  vscodeLanguageIds: string[];
  [k: string]: any;
}
export interface SupportOption {
  array?: boolean;
  choices?: SupportOptionChoice[];
  default: string | number | boolean;
  deprecated?: string;
  description: string;
  oppositeDescription?: string;
  range?: SupportOptionRange;
  redirect?: SupportOptionRedirect;
  since?: string;
  type: "boolean" | "choice" | "int" | "path";
  [k: string]: any;
}
export interface SupportOptionChoice {
  deprecated?: string;
  description?: string;
  redirect?: string | number | boolean;
  since?: string;
  value: string | boolean;
  [k: string]: any;
}
export interface SupportOptionRange {
  end: number;
  start: number;
  step: number;
  [k: string]: any;
}
export interface SupportOptionRedirect {
  options: string;
  value: string | number | boolean;
  [k: string]: any;
}
export interface Parser {
  astFormat: string;
  hasPragma?: {
    [k: string]: any;
  };
  locEnd: {
    [k: string]: any;
  };
  locStart: {
    [k: string]: any;
  };
  parse: {
    [k: string]: any;
  };
  preprocess?: {
    [k: string]: any;
  };
  [k: string]: any;
}
export interface Printer {
  canAttachComment?: {
    [k: string]: any;
  };
  embed?: {
    [k: string]: any;
  };
  handleComments?: {
    endOfLine?: {
      [k: string]: any;
    };
    ownLine?: {
      [k: string]: any;
    };
    remaining?: {
      [k: string]: any;
    };
    [k: string]: any;
  };
  hasPrettierIgnore?: {
    [k: string]: any;
  };
  insertPragma?: {
    [k: string]: any;
  };
  massageAstNode?: {
    [k: string]: any;
  };
  printComments?: {
    [k: string]: any;
  };
  willPrintOwnComments?: {
    [k: string]: any;
  };
  [k: string]: any;
}

export type Result = {
  id: number;
  name: string;
  [k: string]: any;
}[];

export default function getUsers(options: Options): Promise<Result>;
